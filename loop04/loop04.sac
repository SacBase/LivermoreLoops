/*******************************************************************************
 *
 * Livermore Loop no 4
 *
 * banded linear equations
 *
 *******************************************************************************/

use StdIO: all;
use Array: all;
use RTimer: all;


#ifndef VARIANT
#define VARIANT APL
#endif

#define APPEND(v) Loop4_ ## v
#define FULL(v) APPEND(v)
#define LOOP FULL( VARIANT)

#define STR(s) #s
#define STRING(s) STR(s)


#ifndef SIZE
#define SIZE 1001
#endif

double[.] Loop4_C( int m, int n, double[SIZE] x, double[SIZE] y)
{
  for( k=6; k<SIZE; k+=m) {
    lw = k-6;
    temp = x[k-1];
    for( j=4; j<n; j+=5) {
      temp -= x[lw] * y[j];
      lw++;
    }
    x[k-1] = y[4] * temp;
  }
  return x;
}

double[.] Loop4_N( int m, int n, double[SIZE] x, double[SIZE] y)
{
  x = with {
        ([5] <= [k] < [SIZE-1] step [m]) {
          tmp = x[k];
          tmp -= with {
                   ( [0] <= [j] < [n/5]) : x[j+k-6] * y[4+5*j];
                 } : fold( +, 0d);
        } : y[4] * tmp;
      } : modarray( x);
  return x;
}

double Loop4_APL(int m, int n, double[SIZE] x, double[SIZE] y)
{
  chunk = n/5;
  x = with {
        ([5] <= [k] < [SIZE-1] step [m]) {
          tmp = x[k];
          tmp -= sum( take( [chunk], drop([k-6], x)) *
                      take( [chunk], condense( [5], drop( [4], y))));
        } : y[4] * tmp;
      } : modarray( x);
  return(x);
}

inline double BandedIp( int[+] offset, int from, int to, double[+] x, double[+] y)
{
  band_mult = with {
                ( [from] <= iv <= [to] ) : ( x[ (offset-6) + iv ] * y[5*iv - 1] );
              } : fold( +, 0d );

  return( band_mult);
}

double[.] Loop4_G( int m, int n, double[SIZE] x, double[SIZE] y)
{
  steps = n / 5;

  if( steps < 6 ) {
    t1 = x[[5]]   - BandedIp( [5], 1, steps, x, y);
    t2 = x[[502]] - BandedIp( [502], 1, steps, x, y);
    t3 = x[[999]] - BandedIp( [999], 1, steps, x, y);
  } else {
    t1 = ( (1d-y[[29]]) * ( x[[5]] - BandedIp( [5], 1, 5, x, y)) )
         - BandedIp( [5], 7, steps, x, y);
    t2 = ( (1d-y[[29]]) * ( x[[502]] - BandedIp( [502], 1, 5, x, y)) )
         - BandedIp( [502], 7, steps, x, y);
    t3 = ( (1d-y[[29]]) * ( x[[999]] - BandedIp( [999], 1, 5, x, y)) )
         - BandedIp( [999], 7, steps, x, y);
  }

  x[[5]] = t1 * y[[4]];
  x[[502]] = t2 * y[[4]];
  x[[999]] = t3 * y[[4]];

  return(x);
}



inline double[.] genArray(int size)
{
  A = tod( 1 + iota(size));
  return(A);
}


int main ()
{
  double[ SIZE] x;

  timer = createRTimer();

  rep = (int) FibreScanIntArray();             /* 500000 */

  m = (SIZE-7)/2;
  n = SIZE;
  x = genArray( SIZE);
  y = x;

  printf( "Running " STRING( LOOP) "\n");
  printf( "Number of repetitions: %d\n", rep);
  printf( "Vector length        : %d\n", SIZE);

  startRTimer( timer);
  noLir = 0.0;
  for (i=0; i<rep; i++){
    x = LOOP( m, n, x, y);
  }
  stopRTimer( timer);

  printf( "The first element of the result is : %f\n", x[0]);

  numFlops = tod(rep)*tod((n-6)/m)*tod((n-4)/5)*2.0;

  printf( "Wall Clock Time spent           : %6.3f secs\n", getRTimerDbl( timer));
  printf( "Computer Performance achieved   : %6.2f GFlops\n", (tod(numFlops)/1000000000.0) / getRTimerDbl( timer));
  
  return( 0);
}

